---
title: "멀티플레이어 피카츄 배구(작성중)"
excerpt: "이 프로젝트는 피카츄 배구를 모작하고, 멀티플레이어 기능을 추가한 프로젝트입니다."
order: 3
toc: true
toc_sticky: true
header:
  teaser: assets/images/placeholder.gif
---

## 1. 개요
### 1.1 프로젝트 소개
멀티플레이어 피카츄 배구는 한국산업기술대학교의 네트워크 게임 프로그래밍 수업에서 진행한 팀프로젝트입니다.
네트워크 게임 프로그래밍 수업에서는 소켓 프로그래밍, TCP 및 UDP, 멀티스레드, 소켓 옵션 및 소켓 입출력 모델 등을 학습하였습니다.

텀프로젝트는 세 명이 한 팀을 이루어 진행하였고 텀프로젝트에는 다음과 같은 요구사항이 있었습니다.
1. 실시간으로 데이터를 주고 받는 것이 보여야 한다. 즉, 체스와 같이 요청-응답 방식의 게임은 요구사항에 부합하지 못한다.
2. 수업에서의 학업 성취도를 평가하기 위해 윈도우 소켓을 C++와 함께 사용하여야 한다.
3. 프로젝트의 제출 기한보다 빠르게 제출하면 추가 점수가 부여된다.
4. 클라이언트의 기술적인 복잡도는 평가에 반영되지 않는다.

이러한 요구사항을 만족하기 위해 저희 팀은 피카츄 배구를 모작하고 멀티플레이어 기능을 추가하기로 결정했습니다. 이유는 다음과 같습니다.
첫째, 추가적인 기획 비용이 필요하지 않아 시간이 절약된다. 피카츄 배구는 이미 존재하는 게임으로 게임의 기획, 룰에 대한 기틀이 잡혀있습니다.
둘째, 게임 로직이 간단하여 시간이 절약된다. 피카츄 배구의 로직은 플레이어의 캐릭터 조작, 점수 및 승패, 충돌과 공의 물리, 피카츄의 스파이크 능력 정도로 클라이언트의 많은 로직이 필요하지 않습니다.
셋째, 실시간으로 데이터를 주고 받는 것을 보여주기 용이하다. 피카츄 배구에는 점수 시스템, 승패, 위치 이동과 같은 네트워크 게임의 기본적인 요소를 담고 있고 이들이 모두 한 화면에 나타납니다.

멀티플레이어 피카츄 배구에서는 화면을 렌더링하기 위한 OpenGL을 사용하였습니다. 이유는 당시 OpenGL은 팀원 모두가 그래픽스 프로그래밍 수업으로 숙달되어 있었으나, SFML이나 SDL과 같은 라이브러리는 추가적인 학습이 필요했습니다.

### 1.2 게임 소개
**비디오**<br/>
멀티플레이어 피카츄 배구는 최대 4명의 플레이어들이 2개의 팀을 이루어 한 맵에 모여서 공을 네트 위로 넘겨 상대방의 지역에 공격을 성공하여 일정 점수에 먼저 도달하는 팀이 승리하는 게임입니다.
각 클라이언트는 닉네임을 입력하여 서버에 로그인하고, 4명의 플레이어가 모일 때까지 채팅창에서 채팅을 하며 기다립니다.
4명의 플레이어가 모일 시 게임이 시작됩니다.
플레이어는 자신의 지역에서 배구공을 터치하여 상대방 지역으로 공을 넘기고, 상대방 지역 바닥에 공이 떨어지면 점수를 획득합니다.
공이 같은 팀의 지역 바닥에 공이 떨어진다면 상대방이 점수를 획득합니다.
먼저 15점을 획득하는 팀이 승리합니다.
### 1.3 게임 조작법
이동
 ←: 왼쪽 이동, 
 →: 오른쪽 이동, 
 ↑: 위로 이동, 
 ↓: 아래로 이동
파워히트: 스페이스바

### 1.4 시작하기
게임을 다운받고 사용하는 방법에 대해 설명하세요

## 2. 네트워킹
### 2.1 개요
네트워킹에 사용한 라이브러리 기술등을 간략하게 언급하세요.
### 2.2 하이레벨 디자인
전체적인 흐름을 플로우 차트와 함께 설명하시오
### 2.3 실행 구현
- 서버는 실행 시 먼저 클라이언트를 받기 위한 Listening Thread를 생성합니다.
- Listening Thread는 WinSock을 초기화 하고 Listening Socket을 만들어서 클라이언트를 기다립니다.
- Listening Thread는 클라이언트가 들어오면 통신을 위한 새로운 쓰레드를 만들어주고, 최대로 받을 수 있는 클라이언트, 게임을 하기 위해 받을 수 있는 클라이언트를 받으면 ExitThread를 호출합니다.
- 클라이언트는 서버와 연결이 성공되면 로그인 상태로 넘어갑니다.

### 2.4 로그인 구현
- 클라이언트는 앞서 실행 시 서버가 만든 Communication Thread와 1대1로 통신을 하면서 데이터를 주고 받습니다.
- Communication Thread는 클라이언트로부터 데이터를 받으면 Queue에 넣고 Main Thread가 모든 연산을 수행할 때까지 대기합니다.
- Main Thread는 Queue있는 정보를 하나씩 꺼내면서 Login이 유효한지 검사를 하고 그 결과값을 클라이언트마다 할당된 메모리 공간에 보내고 Communication Thread를 깨웁니다.
- Communication Thread는 Main Thread가 계산하고 메모리 공간에 보내준 데이터를 다시 클라이언트에 보냅니다.
- 클라이언트는 서버가 보내준 로그인 결과값을 바탕으로 로그인이 유효하면 로비로 넘어가고, 그렇지 않으면 다시 로그인을 시도합니다.
- 앞서 실행시 만들었던 Listening Thread는 다른 쓰레드와 병렬적으로 동작하면서 지속적으로 다른 클라이언트를 기다립니다.

### 2.5 로비 구현
- 클라이언트는 앞서 실행 시 서버가 만든 Communication Thread와 1대1로 통신을 하면서 데이터를 주고 받습니다.
- Communication Thread는 클라이언트로부터 데이터를 받으면 Queue에 넣고 Main Thread가 모든 연산을 수행할 때까지 대기합니다.
- Main Thread는 Queue에 있는 정보를 하나씩 꺼내면서 채팅창을 최신화하고, 게임이 시작될 수 있는지를 지속적으로 검사합니다. 그리고 그 결과값을 클라이언트마다 할당된 메모리 공간에 보내고 Communication Thread를 깨웁니다.
- Communication Thread는 Main Thread가 계산하고 메모리 공간에 보내준 데이터를 다시 클라이언트에 보냅니다.
- 클라이언트는 서버가 보내준 결과값을 바탕으로 게임이 시작될 수 있으면, 게임을 시작하고, 그렇지 않으면 지속적으로 채팅창을 렌더링하고 채팅을 이어갑니다.
- 앞서 실행시 만들었던 Listening Thread는 다른 쓰레드와 병렬적으로 동작하면서 지속적으로 다른 클라이언트를 기다립니다.

### 2.6 인게임 구현
- 클라이언트는 앞서 실행시 서버가 만든 Communication Thread와 1대1로 통신을 하면서 데이터를 주고 받습니다.
- Communication Thread는 클라이언트로부터 데이터를 받으면 Queue에 넣고 Main Thread가 모든 연산을 수행할 때까지 대기합니다.
- Main Thread는 Queue에 있는 정보를 하나씩 꺼내면서, 플레이어의 위치, 플레이어의 애니메이션, 팀의 점수 등, 게임 로직을 계산합니다. 그리고 그 결과값을 클라이언트마다 할당된 메모리 공간에 보내고 Communication Thread를 깨웁니다.
- Communication Thread는 Main Thread가 계산하고 메모리 공간에 보내준 데이터를 다시 클라이언트에 보냅니다.
- 클라이언트는 서버가 보내준 결과값을 바탕으로 게임 오브젝트들을 렌더링하고 게임을 이어나갑니다.
- 클라이언트와 서버는 게임이 종료되면 모든 연결을 끊고 종료합니다.

<!-- ## 3. 렌더링
### 3.1 개요
렌더링에 어떠한 라이브러리 기술등을 썼는지 간략하게 언급하세요.
### 3.2 하이레벨 디자인
렌더링 흐름에 대해 간략하게 설명하세요.
텍스쳐 로딩
### 3.3 구현 -->